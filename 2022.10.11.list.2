# include "list.h"
SLTNode* BuySListNode(SLTDataType x)
{
  SLTNode * newnode =(SLTNode *)malloc(sizeof(SLTNode));
  if( newnode == NULL)
  {
    perror("Error");
    exit(-1);
  }
  newnode -> data = x;
  newnode -> next = NULL;
  return newnode;
}
//尾插
// 插入第一个节点，改变的事SListNode* 用结构体的指针的指针
// 尾插 改变的是结构体SListNode
void SListPushBack(SLTNode **pphead,SLTDataType x)
{
    assert(pphead);
    SLTNode *newnode = BuySListNode(x);
    if(*pphead == NULL)
    {
         *pphead = newnode;
    }
    SLTNode *tail = pphead;
    while(tail ->next)
    {
         tail = tail->next;
    }
    tail->next = newnode;
}
// 单链表头插
void SListPushBack(SLTNode** pplist, SLTDataType x)
{

    assert(pplist);
    SLTNode *newnode = BuySListNode(x);
    newnode->next=*pplist; //指向原来的头
    *pplist = newnode; //新的头就是插入的
}
// 单链表的尾删
void SListPopBack(SLTNode** pplist);
{
     assert(pplist);
     SLTNode *tail = *pphead;
     while(tail -> next)
     {
        tail = tail->next;
     }
     free(tail->next);
     tail->next = NULL;
} 
// 单链表头删
void SListPopFront(SLTNode** pplist)
{
     assert(pplist);
     SLTNode *head = *pplist;
     *pplist = (*pplist)->next;
     free(head);
     head =NULL;
}
// 单链表查找
SLTNode* SListFind(SLTNode* plist, SLTDataType x)
 {
     SLTNode *tail = plist;
     while(tail)
     {
        if(tail -> data == x)
        {
            return tail;
        }
        tail = tail -> next;
     }
     return NULL;
}

//单链表在pos位置之后插入x
void SListInsertAfter(SLTNode* pos, SLTDataType x)
{
      
}
//之前插入
void SListInsertfront(SLTNode** pphead, SLTNode *pos,SLTNode x)
{
      assert(pphead);
      assert(pos);
      SLTNode *tail = *plist;
      while(tail->next != pos)
      {
         tail = tail->next;
      }
       SLTNode *newnode = BuySListNode(x);
       tail ->next = newnode;
       newnode->next = pos;

}
